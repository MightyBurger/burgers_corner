<!doctype html><html class=dark lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://mightyburger.net name=base><title>
         Curveball
        
    </title><meta content=Curveball property=og:title><meta content="Curve generator for Neverball" property=og:description><meta content="Curve generator for Neverball" name=description><link href=favicon.png rel=icon type=image/png><link href=https://mightyburger.net/fonts.css rel=stylesheet><script src=https://mightyburger.net/js/codeblock.js></script><script src=https://mightyburger.net/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="burger's corner" href=https://mightyburger.net/atom.xml rel=alternate type=application/atom+xml><link href=https://mightyburger.net/theme/dark.css rel=stylesheet><script src=https://mightyburger.net/js/themetoggle.js></script><script>setTheme("dark");</script><link href=https://mightyburger.net/main.css media=screen rel=stylesheet><script src=https://mightyburger.net/js/mermaid.js></script><script src="https://mightyburger.net/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://mightyburger.net>burger's corner</a><div class=socials></div></div><nav><a href=https://mightyburger.net/projects style=font-size:1rem;font-family:var(--header-font);margin-left:1em>projects</a><a href=https://mightyburger.net/posts style=font-size:1rem;font-family:var(--header-font);margin-left:1em>blog</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://mightyburger.net/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div></nav></header><main><article><div class=title><div class=page-header>Curveball</div><div class=meta><span class=submeta> <time>7</time> min </span></div></div><section class=body><p>Curveball is my curve generator tool for <a href=https://neverball.org/>Neverball</a>.<p><img alt="curveball logo" src=/projects/curveball.png><p>You can use Curveball <a href=https://curveball.mightyburger.net>on the web</a>!<p>The source code is available on <a href=https://github.com/MightyBurger/curveball>Github</a>. You can find some more screenshots there.<p>If you'd rather run Curveball as a desktop app, you can download a release from Github or compile it yourself. Don't worry - compiling Curveball is easy, especially if you already have Rust.<p>Oh yeah. This thing is written in Rust ðŸ¦€. That means it must be good, right?<h1 id=curve-madness>Curve madness</h1><p>Why Curveball? I'm working on a level set for an open-source game called <a href=https://neverball.org/>Neverball</a>, and I needed some fancy shapes.<p>Neverball already has <a href=https://github.com/Neverball/neverball/blob/master/contrib/curve.c>a curve generating tool</a> called <code>curve.c</code>. It was good enough for all the existing Neverball level sets (except Nevermania - <a href=https://github.com/fwp>fwp</a> must have written a couple of his own scripts). But <code>curve.c</code> only generates one kind of curve: a circular arc. Granted, it gives you a lot of knobs to turn.<p>I needed curves <code>curve.c</code> couldn't make, so I wrote some scripts to fill the gaps.<p>I later had an idea to combine these random scripts into one tool and have a visualizer for it, like <a href=https://play.neverball.org/curve.js/>curve.js</a>. I started working on it and got a little carried away. The final result is Curveball!<h1 id=how-does-it-work>How does it work?</h1><p>My early scripts were very basic, but I gradually found neat abstractions to make it better and less cumbersome.<h2 id=ask-for-the-universe>Ask for the universe</h2><p>Neverball levels are made up of many "brushes". Each brush is a little piece of geometry.<p>Brushes are defined in a strange way: each brush is an <em>intersection of halfspaces</em>. That sounds intimidating if you haven't heard of it before, so let me explain.<p>Imagine you form a brush like this: first, let your brush take up the entire universe. Then, cut the universe in half over and over again until you're left with a little piece.<p>It's bizarre, but there's technical reasons why it is done this way, such as making the collision code easier.<p>Now we need some way to describe these shapes in a text file. Neverball parses the <a href=https://quakewiki.org/wiki/Quake_Map_Format>Quake map format</a>, where each "cut" is defined by three points in the plane. These points have to be in a certain order; if you get it wrong, you might accidentally cut away the wrong half of the universe!<p>If you're curious, here's an example of the data for a cube:<pre class=language-QUAKE data-lang=QUAKE style=color:#bfbab0;background-color:#0f1419><code class=language-QUAKE data-lang=QUAKE><span>{
</span><span>"classname" "worldspawn"
</span><span>// brush 0
</span><span>{
</span><span>( 0 0 64 ) ( 0 64 64 ) ( 64 0 64 ) mtrl/invisible 0 0 0 0.5 0.5 0 0 0
</span><span>( 0 0 0 ) ( 0 0 64 ) ( 64 0 64 ) mtrl/invisible 0 0 0 0.5 0.5 0 0 0
</span><span>( 0 0 64 ) ( 0 0 0 ) ( 0 64 64 ) mtrl/invisible 0 0 0 0.5 0.5 0 0 0
</span><span>( 64 0 64 ) ( 64 64 64 ) ( 64 64 0 ) mtrl/invisible 0 0 0 0.5 0.5 0 0 0
</span><span>( 64 64 0 ) ( 64 64 64 ) ( 0 64 64 ) mtrl/invisible 0 0 0 0.5 0.5 0 0 0
</span><span>( 0 0 0 ) ( 64 0 0 ) ( 64 64 0 ) mtrl/invisible 0 0 0 0.5 0.5 0 0 0
</span><span>}
</span><span>}
</span></code></pre><p>The points are in the parenthesis. Everything after that is related to textures.<h2 id=convexity>Convexity</h2><p>Unfortunately, the way brushes work means every single brush has to be <a href=https://en.wikipedia.org/wiki/Convex_polytope>convex</a>. Yet, most curves are not convex. So, curves generally need to be made up of a bunch of smaller brushes.<h2 id=an-easier-way>An easier way</h2><p><code>curve.c</code> and my early scripts just carefully chose the points manually. This is really error prone and a bit of a pain. It turns out our problem is the kind a <a href=https://en.wikipedia.org/wiki/Convex_hull_algorithms>convex hull algorithm</a> can solve. I found the <a href=https://crates.io/crates/chull>chull crate</a>, which implements a convex hull algorithm in Rust. Now I can give <code>chull</code> a bunch of points and let it figure out how to make my shape out of them. Cool!<p>This made it easy to throw together new curve generators quickly. However, it also made assigning textures to each face painful. <a href=https://trenchbroom.github.io/>Trenchbroom</a> makes it quick to paint a texture on lots of faces, so I opted not to worry about this.<p>Using <code>chull</code> made it easy to generate these curves just by defining the vertices. But there was still more improvement to be had.<h2 id=the-key-idea-extrusions>The key idea: extrusions</h2><p>I discovered a really neat abstraction for generating these curves. It was inspired by mechanical CAD software like <a href=https://www.solidworks.com/>Solidworks</a>. The idea is you <em>define a 2D profile</em> that you <em>extrude into 3D space</em>.<p>In Curveball, the 2D profile is copied multiple times along the path. Curveball then takes all the vertices in two adjacent faces and runs it through <code>chull</code> to produce a brush. Repeat until you reach the end of the path, and the curve is made.<p>This feels really natural to generate shapes with, and it opens up a world of options. Every combination of <em>profile</em> and <em>path</em> makes a new curve. Some are really weird and probably aren't useful, but there's a lot of interesting, useful curves you can make with it. If I code up $m$ different profiles and $n$ different paths, now I can produce $m \cdot n$ different curves! Manually coding every permutation would have taken ages.<h2 id=orienting>Orienting</h2><p>An interesting problem to solve is rotating the profile along the path. This is especially natural for the <em>revolve</em> path, but it could be useful for other paths.<p>I ran into trouble programming this. My initial attempts failed because they all had the same misunderstanding. It turns out the <em>point</em> of the path and the <em>direction</em> you are headed isn't enough information to know how you should rotate! There's a degree of freedom I was missing: torsion.<p>I eventually stumbled upon the <a href=https://en.wikipedia.org/wiki/Frenet%E2%80%93Serret_formulas>Frenet frame</a>. If I can define $\mathbf{T}$, $\mathbf{N}$, and $\mathbf{B}$ vectors at any point along the curve, then I simply multiply the matrix $\left[ \mathbf{T}, \mathbf{N}, \mathbf{B} \right]$ by the point to rotate that point.<p>You can use interesting techniques like integrating the <a href=https://en.wikipedia.org/wiki/Frenet%E2%80%93Serret_formulas>Frenet-Serret formulas</a> or finding the <a href=https://medium.com/intuition/lockdown-geometry-rotation-minimizing-frames-ff373d2f355b>rotation-minimizing frames</a> to find these vectors, but the paths in Curveball are all simple enough it's easy to just define the three vectors directly, so that's what I did.<p>Rotating the profile along the path isn't always the desired behavior, so I made it optional in Curveball.<p>This is the function signature:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#f73>pub fn </span><span style=color:#ffb454>extrude</span><span>&LTPRF, PTH>(
</span><span>    </span><span style=color:#f29718>n</span><span style=color:#bfbab0cc>: </span><span style=color:#f73>u32</span><span>,
</span><span>    </span><span style=color:#f29718>profile</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>PRF,
</span><span>    </span><span style=color:#f29718>path</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>PTH,
</span><span>    </span><span style=color:#f29718>profile_orientation</span><span style=color:#bfbab0cc>:</span><span> ProfileOrientation,
</span><span>) </span><span style=color:#bfbab0cc>-> </span><span>CurveResult<</span><span style=color:#39bae6;font-style:italic>Vec</span><span>&LTBrush>>
</span><span style=color:#f73>where
</span><span>    PRF</span><span style=color:#bfbab0cc>:</span><span> Profile,
</span><span>    PTH</span><span style=color:#bfbab0cc>:</span><span> Path,
</span></code></pre><p>Not too bad! A <code>Profile</code> is something that produces a vector of points in a plane, possibly varying along the path. A <code>Path</code> is something that produces a point and a Frenet Frame that varies to produce the path.<h2 id=exceptions-to-the-rule>Exceptions to the rule</h2><p>In addition to an <strong>Extrusion</strong>, curveball can also generate three other curves I call <strong>Curve Classic</strong>, <strong>Curve Slope</strong>, and <strong>Rayto</strong>.<p><strong>Curve Classic</strong> <em>can</em> in fact be generated as an extrusion. This is because <code>extrude()</code> can accept 2D profiles that vary along the path. I opted to implement it separately to make the interface similar to <code>curve.c</code>.<p><strong>Rayto</strong> can also be generated as an extrusion. You just have to make really clever use of the functionality I describe above. That would be a pain, so instead I implement it directly.<p><strong>Curve Slope</strong> is the only curve that cannot be generated by <code>extrude()</code>. The reason is it generates brushes differently. When you make this curve in Curveball, you'll notice the brushes look like triangular pieces.<h1 id=what-s-next>What's next?</h1><p>It's time to use this tool! I have some levels I paused because I needed a certain curve shape. Now I can go forward and make some fun levels.<p>I'm excited to see what the Neverball community comes up with using this tool.<p><em>Note: I've made some small edits to this post to fix technical details.</em></section></article></main></div>